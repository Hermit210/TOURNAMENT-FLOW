<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TournamentFlow â€” Professional Gaming Tournament Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
    <script src="./js/tournament-data.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'primary': {
                50: '#f0f9ff',
                100: '#e0f2fe',
                200: '#bae6fd',
                300: '#7dd3fc',
                400: '#38bdf8',
                500: '#0ea5e9',
                600: '#0284c7',
                700: '#0369a1',
                800: '#075985',
                900: '#0c4a6e',
              },
              'accent': {
                500: '#8b5cf6',
                600: '#7c3aed',
              }
            },
            fontFamily: {
              'sans': ['Inter', 'system-ui', 'sans-serif'],
            },
            animation: {
              'chain-roll': 'chainRoll 20s linear infinite',
              'float': 'float 6s ease-in-out infinite',
              'glow': 'glow 2s ease-in-out infinite alternate',
            }
          }
        }
      }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  </head>
  <body class="bg-white text-gray-900 font-sans antialiased">
    
    <!-- Navigation -->
    <nav class="fixed top-0 w-full z-50 bg-white/80 backdrop-blur-xl border-b border-gray-200">
      <div class="max-w-7xl mx-auto px-6 py-4">
        <div class="flex items-center justify-between">
          <div class="flex items-center space-x-3">
            <div class="w-10 h-10 bg-gradient-to-br from-primary-500 to-primary-600 rounded-xl flex items-center justify-center shadow-lg">
              <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20">
                <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
              </svg>
            </div>
            <span class="text-2xl font-bold bg-gradient-to-r from-primary-600 to-primary-800 bg-clip-text text-transparent">TournamentFlow</span>
          </div>
          
          <div class="hidden md:flex items-center space-x-8">
            <a href="./tournaments.html" class="text-gray-600 hover:text-primary-600 font-medium transition-colors">Tournaments</a>
            <a href="./rewards.html" class="text-gray-600 hover:text-primary-600 font-medium transition-colors">Rewards</a>
            <a href="./docs.html" class="text-gray-600 hover:text-primary-600 font-medium transition-colors">Documentation</a>
          </div>
          
          <button id="mobile-menu" class="md:hidden p-2 text-gray-600 hover:text-primary-600">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
            </svg>
          </button>
        </div>
      </div>
    </nav>

    <!-- Hero Section -->
    <section class="relative min-h-screen flex items-center justify-center overflow-hidden bg-gradient-to-br from-gray-50 to-blue-50">
      <!-- 3D Blockchain Animation Background -->
      <div class="absolute inset-0 z-0">
        <canvas id="blockchain-canvas" class="w-full h-full"></canvas>
        <div class="absolute inset-0 bg-gradient-to-t from-white/40 via-transparent to-white/20"></div>
      </div>
      
      <div class="relative z-10 max-w-7xl mx-auto px-6 py-32 text-center">
        <div class="space-y-8">
          <!-- Badge -->
          <div class="inline-flex items-center gap-2 px-4 py-2 bg-primary-50 border border-primary-200 rounded-full text-primary-700 font-medium">
            <div class="w-2 h-2 bg-primary-500 rounded-full animate-pulse"></div>
            Built with Kwala Workflows
          </div>
          
          <!-- Main Heading -->
          <h1 class="text-5xl md:text-7xl lg:text-8xl font-black tracking-tight leading-none">
            <span class="bg-gradient-to-r from-gray-900 via-primary-700 to-primary-600 bg-clip-text text-transparent">
              Professional
            </span>
            <br />
            <span class="text-gray-900">Gaming Tournaments</span>
          </h1>
          
          <!-- Subtitle -->
          <p class="text-xl md:text-2xl text-gray-600 max-w-4xl mx-auto leading-relaxed">
            Advanced decentralized tournament platform for competitive gaming.<br />
            <span class="font-semibold text-primary-600">Secure, transparent, and automated.</span>
          </p>
          
          <!-- CTA Buttons -->
          <div class="flex flex-col sm:flex-row gap-4 justify-center pt-8">
            <a href="./tournaments.html" class="px-8 py-4 bg-gradient-to-r from-primary-500 to-primary-600 hover:from-primary-600 hover:to-primary-700 text-white rounded-2xl font-bold text-lg transition-all duration-300 transform hover:scale-105 shadow-xl hover:shadow-2xl">
              Join Tournament
            </a>
            <a href="./docs.html" class="px-8 py-4 border-2 border-gray-300 hover:border-primary-500 text-gray-900 hover:text-primary-600 rounded-2xl font-bold text-lg transition-all duration-300 hover:bg-primary-50 shadow-lg hover:shadow-xl">
              Learn More
            </a>
          </div>
        </div>
      </div>
    </section>

    <!-- 3D Global Network -->
    <section class="py-20 bg-white">
      <div class="max-w-7xl mx-auto px-6">
        <div class="text-center mb-16">
          <h2 class="text-4xl md:text-5xl font-bold text-gray-900 mb-6">Global Tournament Network</h2>
          <p class="text-xl text-gray-600 max-w-3xl mx-auto">Experience our worldwide tournament ecosystem in real-time</p>
        </div>
        
        <!-- 3D Globe Container -->
        <div class="relative">
          <div class="bg-gradient-to-br from-slate-900 to-blue-900 rounded-3xl overflow-hidden shadow-2xl">
            <canvas id="global-network-canvas" class="w-full h-96 md:h-[500px] block"></canvas>
            
            <!-- Floating Stats -->
            <div class="absolute top-6 left-6 bg-white/10 backdrop-blur-sm rounded-xl p-4 text-white">
              <div class="text-sm opacity-80 mb-1">Active Nodes</div>
              <div class="text-2xl font-bold" id="active-nodes">247</div>
            </div>
            
            <div class="absolute top-6 right-6 bg-white/10 backdrop-blur-sm rounded-xl p-4 text-white">
              <div class="text-sm opacity-80 mb-1">Network Speed</div>
              <div class="text-2xl font-bold" id="network-speed">98.7%</div>
            </div>
            
            <div class="absolute bottom-6 left-6 bg-white/10 backdrop-blur-sm rounded-xl p-4 text-white">
              <div class="text-sm opacity-80 mb-1">Global Reach</div>
              <div class="text-2xl font-bold" id="global-reach">156</div>
            </div>
            
            <div class="absolute bottom-6 right-6 bg-white/10 backdrop-blur-sm rounded-xl p-4 text-white">
              <div class="text-sm opacity-80 mb-1">Connections</div>
              <div class="text-2xl font-bold" id="connections">1.2K</div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Features Section -->
    <section class="py-20 bg-gray-50">
      <div class="max-w-7xl mx-auto px-6">
        <div class="text-center mb-16">
          <h2 class="text-4xl md:text-5xl font-bold text-gray-900 mb-6">Why Choose TournamentFlow</h2>
          <p class="text-xl text-gray-600 max-w-3xl mx-auto">Built for the future of competitive gaming with cutting-edge blockchain technology</p>
        </div>
        
        <div class="grid md:grid-cols-3 gap-8">
          <div class="bg-white rounded-3xl p-8 shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
            <div class="w-16 h-16 bg-gradient-to-br from-primary-500 to-primary-600 rounded-2xl flex items-center justify-center mb-6 shadow-lg">
              <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
              </svg>
            </div>
            <h3 class="text-2xl font-bold text-gray-900 mb-4">Automated Tournaments</h3>
            <p class="text-gray-600 text-lg leading-relaxed">Smart contracts handle registration, bracket generation, and prize distribution automatically.</p>
          </div>

          <div class="bg-white rounded-3xl p-8 shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
            <div class="w-16 h-16 bg-gradient-to-br from-blue-500 to-blue-600 rounded-2xl flex items-center justify-center mb-6 shadow-lg">
              <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                <path d="M12 15v2m-6 0h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
              </svg>
            </div>
            <h3 class="text-2xl font-bold text-gray-900 mb-4">Secure & Transparent</h3>
            <p class="text-gray-600 text-lg leading-relaxed">Blockchain technology ensures fair play, transparent results, and secure prize distribution.</p>
          </div>

          <div class="bg-white rounded-3xl p-8 shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
            <div class="w-16 h-16 bg-gradient-to-br from-green-500 to-green-600 rounded-2xl flex items-center justify-center mb-6 shadow-lg">
              <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                <path d="M13 10V3L4 14h7v7l9-11h-7z"/>
              </svg>
            </div>
            <h3 class="text-2xl font-bold text-gray-900 mb-4">Instant Payouts</h3>
            <p class="text-gray-600 text-lg leading-relaxed">Winners receive prizes immediately through smart contracts with no delays or intermediaries.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- How It Works Section -->
    <section class="py-20 bg-white">
      <div class="max-w-7xl mx-auto px-6">
        <div class="text-center mb-16">
          <h2 class="text-4xl md:text-5xl font-bold text-gray-900 mb-6">How It Works</h2>
          <p class="text-xl text-gray-600 max-w-3xl mx-auto">Simple, automated, and secure tournament management</p>
        </div>
        
        <div class="grid md:grid-cols-3 gap-12">
          <div class="text-center">
            <div class="relative mb-8">
              <div class="w-24 h-24 bg-gradient-to-br from-primary-500 to-primary-600 rounded-3xl flex items-center justify-center mx-auto shadow-2xl">
                <span class="text-3xl font-black text-white">1</span>
              </div>
              <div class="absolute -top-2 -right-2 w-8 h-8 bg-yellow-400 rounded-full flex items-center justify-center">
                <svg class="w-4 h-4 text-yellow-800" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                </svg>
              </div>
            </div>
            <h3 class="text-2xl font-bold text-gray-900 mb-4">Create Tournament</h3>
            <p class="text-gray-600 text-lg">Set up your tournament with custom rules, entry fees, and prize distribution.</p>
          </div>

          <div class="text-center">
            <div class="relative mb-8">
              <div class="w-24 h-24 bg-gradient-to-br from-blue-500 to-blue-600 rounded-3xl flex items-center justify-center mx-auto shadow-2xl">
                <span class="text-3xl font-black text-white">2</span>
              </div>
              <div class="absolute -top-2 -right-2 w-8 h-8 bg-green-400 rounded-full flex items-center justify-center">
                <svg class="w-4 h-4 text-green-800" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"/>
                </svg>
              </div>
            </div>
            <h3 class="text-2xl font-bold text-gray-900 mb-4">Players Join</h3>
            <p class="text-gray-600 text-lg">Participants register and pay entry fees through secure smart contracts.</p>
          </div>

          <div class="text-center">
            <div class="relative mb-8">
              <div class="w-24 h-24 bg-gradient-to-br from-green-500 to-green-600 rounded-3xl flex items-center justify-center mx-auto shadow-2xl">
                <span class="text-3xl font-black text-white">3</span>
              </div>
              <div class="absolute -top-2 -right-2 w-8 h-8 bg-purple-400 rounded-full flex items-center justify-center">
                <svg class="w-4 h-4 text-purple-800" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
              </div>
            </div>
            <h3 class="text-2xl font-bold text-gray-900 mb-4">Automatic Payouts</h3>
            <p class="text-gray-600 text-lg">Winners receive prizes instantly when the tournament concludes.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- CTA Section -->
    <section class="py-20 bg-gradient-to-br from-primary-500 to-primary-600">
      <div class="max-w-4xl mx-auto px-6 text-center">
        <h2 class="text-4xl md:text-5xl font-bold text-white mb-6">Ready to Start?</h2>
        <p class="text-xl text-primary-100 mb-8 max-w-2xl mx-auto">Join thousands of gamers already using TournamentFlow for professional esports competitions.</p>
        
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
          <a href="./tournaments.html" class="px-8 py-4 bg-white text-primary-600 rounded-2xl font-bold text-lg transition-all duration-300 transform hover:scale-105 shadow-xl hover:shadow-2xl">
            Browse Tournaments
          </a>
          <a href="./docs.html" class="px-8 py-4 border-2 border-white text-white hover:bg-white hover:text-primary-600 rounded-2xl font-bold text-lg transition-all duration-300 shadow-lg">
            View Documentation
          </a>
        </div>
      </div>
    </section>

    <style>
      @keyframes chainRoll {
        0% { transform: translateX(-100%) rotateY(0deg); }
        100% { transform: translateX(100vw) rotateY(360deg); }
      }
      
      @keyframes float {
        0%, 100% { transform: translateY(0px) rotateX(0deg); }
        50% { transform: translateY(-20px) rotateX(180deg); }
      }
      
      @keyframes glow {
        0% { box-shadow: 0 0 20px rgba(14, 165, 233, 0.3); }
        100% { box-shadow: 0 0 40px rgba(14, 165, 233, 0.6); }
      }
      
      .chain-link {
        animation: float 4s ease-in-out infinite;
      }
      
      .chain-link:nth-child(2n) {
        animation-delay: -1s;
      }
      
      .chain-link:nth-child(3n) {
        animation-delay: -2s;
      }
    </style>

    <script>
      // 3D Blockchain Rolling Animation
      const canvas = document.getElementById('blockchain-canvas');
      const renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: true, 
        alpha: true,
        powerPreference: "high-performance"
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 0);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 15);

      const resize = () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      };
      window.addEventListener('resize', resize);
      resize();

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0x0ea5e9, 1);
      directionalLight.position.set(10, 10, 5);
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0x38bdf8, 0.8, 50);
      pointLight.position.set(-10, 5, 10);
      scene.add(pointLight);

      // Create blockchain chain
      const chainGroup = new THREE.Group();
      scene.add(chainGroup);

      // Chain link geometry
      const linkGeometry = new THREE.BoxGeometry(2, 0.8, 0.8);
      const linkMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0ea5e9,
        metalness: 0.7,
        roughness: 0.3,
        emissive: 0x0369a1,
        emissiveIntensity: 0.1
      });

      // Create multiple chains
      const chains = [];
      for (let chainIndex = 0; chainIndex < 3; chainIndex++) {
        const chain = new THREE.Group();
        
        // Create links in each chain
        for (let i = 0; i < 20; i++) {
          const link = new THREE.Mesh(linkGeometry, linkMaterial.clone());
          
          // Position links
          link.position.x = i * 3 - 30;
          link.position.y = Math.sin(i * 0.5) * 2 + (chainIndex - 1) * 4;
          link.position.z = (chainIndex - 1) * 5;
          
          // Rotate every other link
          if (i % 2 === 0) {
            link.rotation.y = Math.PI / 2;
          }
          
          // Add glow effect
          link.material.color.setHSL(0.55 + chainIndex * 0.1, 0.8, 0.5 + Math.sin(i) * 0.2);
          
          chain.add(link);
        }
        
        chains.push(chain);
        chainGroup.add(chain);
      }

      // Create floating data blocks
      const dataBlocks = [];
      const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
      const blockMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x7dd3fc,
        metalness: 0.5,
        roughness: 0.4,
        transparent: true,
        opacity: 0.8
      });

      for (let i = 0; i < 15; i++) {
        const block = new THREE.Mesh(blockGeometry, blockMaterial.clone());
        block.position.set(
          (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 30
        );
        block.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        
        // Random colors
        block.material.color.setHSL(0.5 + Math.random() * 0.2, 0.7, 0.6);
        
        dataBlocks.push(block);
        scene.add(block);
      }

      // Particle system for network connections
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 200;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 100;
        positions[i + 1] = (Math.random() - 0.5) * 50;
        positions[i + 2] = (Math.random() - 0.5) * 100;

        const color = new THREE.Color();
        color.setHSL(0.55 + Math.random() * 0.1, 0.8, 0.7);
        colors[i] = color.r;
        colors[i + 1] = color.g;
        colors[i + 2] = color.b;
      }

      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const particleMaterial = new THREE.PointsMaterial({
        size: 0.1,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });

      const particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);

      // Animation
      const clock = new THREE.Clock();
      let mouseX = 0, mouseY = 0;

      document.addEventListener('mousemove', (event) => {
        mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
      });

      function animate() {
        const t = clock.getElapsedTime();
        
        // Animate chains rolling
        chains.forEach((chain, index) => {
          chain.position.x = ((t * (2 + index * 0.5)) % 80) - 40;
          chain.rotation.z = t * (0.5 + index * 0.2);
          
          // Animate individual links
          chain.children.forEach((link, linkIndex) => {
            link.rotation.x = t * 2 + linkIndex * 0.5;
            link.position.y += Math.sin(t * 3 + linkIndex + index) * 0.01;
          });
        });

        // Animate data blocks
        dataBlocks.forEach((block, i) => {
          block.rotation.x += 0.01 + i * 0.001;
          block.rotation.y += 0.015 + i * 0.001;
          block.position.y += Math.sin(t * 2 + i) * 0.02;
          
          // Floating motion
          block.position.x += Math.sin(t + i) * 0.01;
          block.position.z += Math.cos(t + i) * 0.01;
        });

        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] += Math.sin(t + positions[i]) * 0.005;
          positions[i] += Math.cos(t + positions[i + 2]) * 0.002;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y = t * 0.1;

        // Camera movement based on mouse
        camera.position.x += (mouseX * 5 - camera.position.x) * 0.05;
        camera.position.y += (mouseY * 5 - camera.position.y) * 0.05;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      // Animated counters
      function animateCounter(elementId, targetValue, duration = 2000) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        const startValue = 0;
        const startTime = Date.now();
        
        function updateCounter() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          const easeOut = 1 - Math.pow(1 - progress, 3);
          const currentValue = Math.floor(startValue + (targetValue - startValue) * easeOut);
          
          element.textContent = currentValue.toLocaleString();
          
          if (progress < 1) {
            requestAnimationFrame(updateCounter);
          }
        }
        
        updateCounter();
      }

      // Initialize counters
      setTimeout(() => {
        animateCounter('active-tournaments', 1247, 2000);
        animateCounter('global-players', 15892, 2500);
        animateCounter('prize-pools', 23470, 3000);
      }, 1000);

      // Mobile menu toggle
      document.getElementById('mobile-menu')?.addEventListener('click', () => {
        // Add mobile menu functionality here
        console.log('Mobile menu clicked');
      });

      // 3D Global Network Globe
      const globalCanvas = document.getElementById('global-network-canvas');
      if (globalCanvas) {
        const globalRenderer = new THREE.WebGLRenderer({ 
          canvas: globalCanvas, 
          antialias: true,
          alpha: true
        });
        globalRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        globalRenderer.setClearColor(0x0f172a, 1);

        const globalScene = new THREE.Scene();
        const globalCamera = new THREE.PerspectiveCamera(75, globalCanvas.clientWidth / globalCanvas.clientHeight, 0.1, 1000);
        globalCamera.position.set(0, 0, 15);

        const resizeGlobal = () => {
          const rect = globalCanvas.getBoundingClientRect();
          globalRenderer.setSize(rect.width, rect.height, false);
          globalCamera.aspect = rect.width / rect.height;
          globalCamera.updateProjectionMatrix();
        };
        window.addEventListener('resize', resizeGlobal);
        resizeGlobal();

        // Lighting
        const globalAmbient = new THREE.AmbientLight(0x404040, 0.4);
        globalScene.add(globalAmbient);

        const globalDirectional = new THREE.DirectionalLight(0x1e40af, 1.5);
        globalDirectional.position.set(10, 10, 5);
        globalScene.add(globalDirectional);

        const globalPoint = new THREE.PointLight(0x3b82f6, 0.8, 50);
        globalPoint.position.set(-10, 5, 10);
        globalScene.add(globalPoint);

        // Create main globe
        const globeGeometry = new THREE.SphereGeometry(6, 64, 64);
        const globeMaterial = new THREE.MeshStandardMaterial({
          color: 0x1e40af,
          transparent: true,
          opacity: 0.2,
          wireframe: true,
          emissive: 0x0f172a,
          emissiveIntensity: 0.1
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        globalScene.add(globe);

        // Create inner globe layers
        const innerGlobe1 = new THREE.Mesh(
          new THREE.SphereGeometry(5.5, 32, 32),
          new THREE.MeshStandardMaterial({
            color: 0x3b82f6,
            transparent: true,
            opacity: 0.15,
            wireframe: true
          })
        );
        globalScene.add(innerGlobe1);

        const innerGlobe2 = new THREE.Mesh(
          new THREE.SphereGeometry(5, 24, 24),
          new THREE.MeshStandardMaterial({
            color: 0x60a5fa,
            transparent: true,
            opacity: 0.1,
            wireframe: true
          })
        );
        globalScene.add(innerGlobe2);

        // Create network nodes
        const nodes = [];
        const nodeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
        const nodeMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x60a5fa,
          emissive: 0x1e40af,
          emissiveIntensity: 0.3
        });

        for (let i = 0; i < 200; i++) {
          const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
          
          // Random position on sphere surface
          const phi = Math.acos(-1 + (2 * i) / 200);
          const theta = Math.sqrt(200 * Math.PI) * phi;
          
          const radius = 6.2;
          const x = radius * Math.cos(theta) * Math.sin(phi);
          const y = radius * Math.sin(theta) * Math.sin(phi);
          const z = radius * Math.cos(phi);
          
          node.position.set(x, y, z);
          node.userData = { 
            originalScale: 1, 
            phase: Math.random() * Math.PI * 2,
            pulseSpeed: 0.5 + Math.random() * 1.5
          };
          
          // Random node colors
          const hue = 0.6 + Math.random() * 0.1;
          node.material.color.setHSL(hue, 0.8, 0.6);
          
          nodes.push(node);
          globalScene.add(node);
        }

        // Create connection lines
        const connections = [];
        const lineMaterial = new THREE.LineBasicMaterial({ 
          color: 0x3b82f6,
          transparent: true,
          opacity: 0.3
        });

        for (let i = 0; i < nodes.length; i++) {
          if (Math.random() > 0.85) {
            const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
            if (randomNode !== nodes[i]) {
              const geometry = new THREE.BufferGeometry().setFromPoints([
                nodes[i].position,
                randomNode.position
              ]);
              const line = new THREE.Line(geometry, lineMaterial.clone());
              line.userData = { 
                opacity: 0.1 + Math.random() * 0.3,
                pulsePhase: Math.random() * Math.PI * 2
              };
              connections.push(line);
              globalScene.add(line);
            }
          }
        }

        // Particle system
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = 300;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
          positions[i] = (Math.random() - 0.5) * 30;
          positions[i + 1] = (Math.random() - 0.5) * 30;
          positions[i + 2] = (Math.random() - 0.5) * 30;

          const color = new THREE.Color();
          color.setHSL(0.6 + Math.random() * 0.1, 0.8, 0.7);
          colors[i] = color.r;
          colors[i + 1] = color.g;
          colors[i + 2] = color.b;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particleMaterial = new THREE.PointsMaterial({
          size: 0.05,
          vertexColors: true,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        globalScene.add(particles);

        // Animation
        const globalClock = new THREE.Clock();
        let globalMouseX = 0, globalMouseY = 0;

        globalCanvas.addEventListener('mousemove', (event) => {
          const rect = globalCanvas.getBoundingClientRect();
          globalMouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          globalMouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        });

        function animateGlobal() {
          const t = globalClock.getElapsedTime();
          
          // Rotate globes at different speeds
          globe.rotation.y = t * 0.1;
          globe.rotation.x = Math.sin(t * 0.05) * 0.1;
          
          innerGlobe1.rotation.y = -t * 0.08;
          innerGlobe1.rotation.x = Math.cos(t * 0.04) * 0.08;
          
          innerGlobe2.rotation.y = t * 0.06;
          innerGlobe2.rotation.z = Math.sin(t * 0.03) * 0.05;

          // Animate nodes
          nodes.forEach((node, i) => {
            const scale = 1 + Math.sin(t * node.userData.pulseSpeed + node.userData.phase) * 0.5;
            node.scale.setScalar(scale);
            
            const intensity = 0.3 + Math.sin(t * 2 + node.userData.phase) * 0.2;
            node.material.emissiveIntensity = intensity;
          });

          // Animate connections
          connections.forEach((connection, i) => {
            const opacity = connection.userData.opacity + Math.sin(t * 3 + connection.userData.pulsePhase) * 0.2;
            connection.material.opacity = Math.max(0.1, opacity);
          });

          // Animate particles
          const positions = particles.geometry.attributes.position.array;
          for (let i = 0; i < positions.length; i += 3) {
            positions[i + 1] += Math.sin(t + positions[i]) * 0.002;
            positions[i] += Math.cos(t + positions[i + 2]) * 0.001;
          }
          particles.geometry.attributes.position.needsUpdate = true;
          particles.rotation.y = t * 0.05;

          // Camera movement based on mouse
          globalCamera.position.x += (globalMouseX * 3 - globalCamera.position.x) * 0.05;
          globalCamera.position.y += (globalMouseY * 3 - globalCamera.position.y) * 0.05;
          globalCamera.lookAt(0, 0, 0);

          globalRenderer.render(globalScene, globalCamera);
          requestAnimationFrame(animateGlobal);
        }
        animateGlobal();

        // Update floating stats
        function updateGlobalStats() {
          const stats = [
            { id: 'active-nodes', base: 247, variance: 10 },
            { id: 'network-speed', base: 98.7, variance: 0.5, suffix: '%' },
            { id: 'global-reach', base: 156, variance: 5 },
            { id: 'connections', base: 1200, variance: 50, format: 'k' }
          ];

          stats.forEach(({ id, base, variance, suffix = '', format }) => {
            const element = document.getElementById(id);
            if (element) {
              const change = (Math.random() - 0.5) * variance;
              let newValue = base + change;
              
              if (format === 'k') {
                element.textContent = (newValue / 1000).toFixed(1) + 'K';
              } else if (suffix === '%') {
                element.textContent = newValue.toFixed(1) + suffix;
              } else {
                element.textContent = Math.floor(newValue);
              }
            }
          });
        }

        // Update stats every 3 seconds
        setInterval(updateGlobalStats, 3000);
        setTimeout(updateGlobalStats, 1000);
      }
    </script>
  </body>
</html>